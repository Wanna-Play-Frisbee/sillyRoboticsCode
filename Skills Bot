#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, in3,    L2,             sensorNone)
#pragma config(Sensor, in4,    L1,             sensorNone)
#pragma config(Sensor, in5,    R1,             sensorLineFollower)
#pragma config(Sensor, in6,    R2,             sensorLineFollower)
#pragma config(Sensor, in7,    ,               sensorLineFollower)
#pragma config(Sensor, in8,    ,               sensorLineFollower)
#pragma config(Sensor, dgtl2,  limit,          sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           L2,            tmotorVex393HighSpeed_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           R1,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           L1,            tmotorVex393HighSpeed_MC29, openLoop, driveLeft, encoderPort, I2C_4)
#pragma config(Motor,  port4,           L3,            tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           R3,            tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_3)
#pragma config(Motor,  port6,           L4,            tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port7,           R4,            tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port8,           mobol,         tmotorVex393HighSpeed_MC29, openLoop, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port9,           mobor,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          R2,            tmotorVex393HighSpeed_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void dmotors(float speedl,float speedr){
	motor[R1] = speedr;
	motor[L1] = speedl;
	motor[R2] = speedr;
	motor[L2] = speedl;
	motor[R3] = speedr;
	motor[L3] = speedl;
	motor[R4] = speedr;
	motor[L4] = speedl;
}

void dleft(float speed){
	motor[L1] = speed;
	motor[L2] = speed;
	motor[L3] = speed;
	motor[L4] = speed;
}

void dright(float speed){
	motor[R1] = speed;
	motor[R2] = speed;
	motor[R3] = speed;
	motor[R4] = speed;
}

void mobo (float speed){
	motor[mobol]=speed;
	motor[mobor]=speed;
}
void logControl(float degs)
{
	float go;
	SensorValue[Gyro] = 0;


	float Lp=-7.5;
	float Lk=0.005;
	float Li=0.1;




	float integral;
	int done=0;
	degs=-degs;
	float error = degs*10 - SensorValue[Gyro];
	float oldError = error;
	float speed;

	while (done<500)
	{
		error=degs*10 - SensorValue[Gyro];
		speed=oldError-error;
		go=(260/(1+pow(2.7,-((error+(Lp*speed))*Lk)))-130);
		oldError = error;

		if (abs(error)<70 && error!=0){
			integral+=(error*Li)/(abs(error));
		}
		else if (abs(integral)>10 && error==0)
		{
			integral=-integral/10;
		}
		else
		{
			integral=0;
		}
		go+=integral;

		if (abs(error)<4)
		{
			done++;
		}
		else
		{
			done=0;
		}
		dmotors(-go,go);
		clearLCDLine(0);
		setLCDPosition(0,0);
		displayNextLCDNumber(error,4);
		displayNextLCDString(" ");
		displayNextLCDNumber(speed);
		wait1Msec(10);
	}
	dMotors(0,0);
}
void dualControl(float degs)
{
	float go;
	SensorValue[Gyro] = 0;


	float Lp=-7.5;
	float Lk=0.005;
	float Li=0.1;

	float kp = 0.3;
	float ki = 0.15;
	float kd = 5;


	degs=-degs;
	float errorl = degs*10 - SensorValue[Gyro];
	float oldErrorl = errorl;
	float speed;
	displayNextLCDString("LOG");
	while (abs(speed)>3 || abs(errorl)>100)
	{
		errorl=degs*10 - SensorValue[Gyro];
		speed=oldErrorl-errorl;
		go=(180/(1+pow(2.7,-((errorl+(Lp*speed))*Lk)))-90);
		oldErrorl = errorl;


		dmotors(-go,go);

		wait1Msec(10);
	}
	bool sqr=false;



	float current = 0;
	float integralActiveZone = 70;
	float allowedError = 10;
	float derZone = 700;

	float errorT;
	float lastError = degs*10 - SensorValue[Gyro];
	float proportion;
	float integral;
	float derivative;
	int donetime = 20;
	int done = 0;
	float lastIntegral = 0;
	float error = degs*10 - SensorValue[Gyro];
	clearLCDLine(0);
	displayNextLCDString("PID");
	while (done<donetime){
		error = degs*10 - SensorValue[Gyro];

		if(abs(error) < integralActiveZone)
		{
			if (error>0)
			{
				errorT += sqrt(error);
			}
			else
			{
				errorT += -sqrt(-error);
			}
		}
		else
		{
			errorT = 0;
		}


		if (abs(errorT) > 600000)
		{
			if (errorT>0){
				errorT=600000;
			}
			else{
				errorT=-600000;
			}
		}



		proportion = error * kp;
		integral = errorT * ki;
		derivative = (error - lastError) * kd;
		lastError = error;

		if (error==0 && (abs(lastIntegral)>6))
		{
			go=-lastIntegral/9;
			errorT=0;
			lastIntegral=0;
			integral=0;
		}
		else
		{
			go=integral;
		}
		lastIntegral = integral;
		if (abs(error) < allowedError)
		{
			done += 1;
		}
		else
		{
			done = 0;
		}
		go += proportion+derivative;
		dmotors(-go,go);
		clearLCDLine(0);
		clearLCDLine(1);
		setLCDPosition(0,0);
		displayNextLCDNumber(proportion,3);
		displayNextLCDString(" ");
		displayNextLCDNumber(integral,2);
		displayNextLCDString(" ");
		displayNextLCDNumber(errorT,2);
		displayNextLCDString(" ");
		displayNextLCDNumber(derivative,3);
		setLCDPosition(1,0);
		displayNextLCDNumber(error,3);
		wait1Msec(10);
	}
	dMotors(0,0);
}
void turnPID(float degs)
{
	SensorValue[Gyro] = 0;
	bool sqr=false;
	float kp;
	float kd;
	if (sqr){
		kp = 1.85;//
	}
	else{
		kp = 0.3;
	}
	float ki = .0005;
	if (sqr){
		kd = 25;//
	}
	else{
		kd = 20;
	}
	float current = 0;
	float integralActiveZone = 80;
	float allowedError = 9;
	float derZone = 700;

	float errorT;
	float lastError = degs*10 - SensorValue[Gyro];
	float proportion;
	float integral;
	float derivative;
	float go;
	int donetime = 500;
	int done = 0;
	float error = degs*10 - SensorValue[Gyro];
	while (done<donetime){
		error = degs*10 - SensorValue[Gyro];

		if(abs(error) < integralActiveZone && error != 0)
		{
			errorT += error;
		}
		else
		{
			errorT = 0;
		}

		if (abs(errorT) > 600000)
		{
			if (errorT>0){
				errorT=600000;
			}
			else{
				errorT=-600000;
			}
		}


		if (sqr){
			if(error>0){
				proportion = pow(error,0.6) * kp;
			}
			else{
				proportion = pow(-error,0.6) * -kp;
			}
		}
		else{
			proportion = error * kp;
		}
		integral = errorT * ki;
		derivative = (error - lastError) * kd;
		lastError = error;

		if (abs(error) > derZone)
		{
			//derivative=0;
		}

		if (abs(error) < allowedError)
		{
			done += 1;
		}
		else
		{
			done = 0;
		}

		if (abs(proportion)<10){
			proportion=0;
		}
		clearLCDLine(0);
		setLCDPosition(0,0);
		displayNextLCDNumber(derivative,4);
		displayNextLCDString(" ");

		go = proportion+derivative+integral;
		dmotors(go,-go);
	}
}
void turnPIDBAS(float degs)
{
	SensorValue[Gyro] = 0;
	bool sqr=false;
	float kp;
	float kd;
	kp = 0.3;
	float ki = .0005;

	kd = -20;
	float current = 0;
	float integralActiveZone = 80;
	float allowedError = 9;
	float derZone = 700;

	float errorT;
	float lastError = degs*10 - SensorValue[Gyro];
	float proportion;
	float integral;
	float derivative;
	float go;
	int donetime = 500;
	int done = 0;
	float midError;
	float error = degs*10 - SensorValue[Gyro];
	while (done<donetime){
		error = degs*10 - SensorValue[Gyro];

		if(abs(error) < integralActiveZone && error != 0)
		{
			errorT += error;
		}
		else
		{
			errorT = 0;
		}

		if (abs(errorT) > 600000)
		{
			if (errorT>0){
				errorT=600000;
			}
			else{
				errorT=-600000;
			}
		}



		proportion = error * kp;
		integral = errorT * ki;
		derivative = (error - lastError) * kd;

		lastError = midError;
		midError = error;
		clearLCDLine(0);
		setLCDPosition(0,0);
		displayNextLCDNumber(derivative,4);
		displayNextLCDString(" ");
		displayNextLCDNumber(error,4);
		displayNextLCDString(" ");
		displayNextLCDNumber(lastError,4);

		if (abs(error) < allowedError)
		{
			done += 1;
		}
		else
		{
			done = 0;
		}

		go = proportion+derivative+integral;
		dmotors(-go,go);
	}
}
void driveFeetDistance(int feet, int masterPower)
{
	//Measures 627.2 ticks per revolution of the output shaft in High Torque Configuration
	//Measures 392 ticks per revolution of the output shaft in High Speed Configuration
	//Measures 261.333 ticks per revolution of the output shaft in Turbo Gear Configuration
	float ticksper = 392;
	int tickGoal = (ticksper * feet * 12) / (3.25 * PI);

	//This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
	int totalTicks = 0;

	//Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
	//-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
	//veering off course at the start of the function.
	int slavePower = masterPower - 0; //PUT offset guess here

	int error = 0;

	int kp = -5;

	resetMotorEncoder(R1);
	resetMotorEncoder(R2);
	resetMotorEncoder(R3);
	resetMotorEncoder(R4);
	resetMotorEncoder(L1);
	resetMotorEncoder(L2);
	resetMotorEncoder(L3);
	resetMotorEncoder(L4);
	//Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.

	while(abs(totalTicks) < tickGoal)
	{
		//Proportional algorithm to keep the robot going straight.
		dleft(masterPower);
		dright(slavePower);

		error = (((getMotorEncoder(L2) + getMotorEncoder(L2) + getMotorEncoder(L4) + getMotorEncoder(L4)) / 4) + ((getMotorEncoder(R2) + getMotorEncoder(R2) + getMotorEncoder(R2) + getMotorEncoder(R2)) / 4));

		slavePower += error / kp;

		//Add this iteration's encoder values to totalTicks.
		totalTicks += ((getMotorEncoder(L2) + getMotorEncoder(L4) + getMotorEncoder(L2) + getMotorEncoder(L4)) / 4);

		resetMotorEncoder(R1);
		resetMotorEncoder(R2);
		resetMotorEncoder(R3);
		resetMotorEncoder(R4);
		resetMotorEncoder(L1);
		resetMotorEncoder(L2);
		resetMotorEncoder(L3);
		resetMotorEncoder(L4);

		wait1Msec(30);

		//Add this iteration's encoder values to totalTicks.
	}
	dmotors(0,0);
}
void driveTillGoal(int masterPower)
{

	//Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
	//-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
	//veering off course at the start of the function.
	int slavePower = masterPower - 0; //PUT offset guess here

	int error = 0;

	int kp = -1;

	resetMotorEncoder(R1);
	resetMotorEncoder(R2);
	resetMotorEncoder(R3);
	resetMotorEncoder(R4);
	resetMotorEncoder(L1);
	resetMotorEncoder(L2);
	resetMotorEncoder(L3);
	resetMotorEncoder(L4);
	//Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.

	while(SensorValue[limit]==0)
	{
		//Proportional algorithm to keep the robot going straight.
		dleft(masterPower);
		dright(slavePower);

		error = (((getMotorEncoder(L2) + getMotorEncoder(L2) + getMotorEncoder(L4) + getMotorEncoder(L4)) / 4) - ((getMotorEncoder(R2) + getMotorEncoder(R2) + getMotorEncoder(R2) + getMotorEncoder(R2)) / 4));
		slavePower += error / kp;

		//Add this iteration's encoder values to totalTicks.

		resetMotorEncoder(R1);
		resetMotorEncoder(R2);
		resetMotorEncoder(R3);
		resetMotorEncoder(R4);
		resetMotorEncoder(L1);
		resetMotorEncoder(L2);
		resetMotorEncoder(L3);
		resetMotorEncoder(L4);

		wait1Msec(10);

		//Add this iteration's encoder values to totalTicks.
	}
	dmotors(0,0);
}
void driveTillLine(int masterPower)
{

	//Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
	//-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
	//veering off course at the start of the function.
	int slavePower = masterPower - 20; //PUT offset guess here

	int error = 0;

	int kp = -2;

	resetMotorEncoder(R1);
	resetMotorEncoder(R2);
	resetMotorEncoder(R3);
	resetMotorEncoder(R4);
	resetMotorEncoder(L1);
	resetMotorEncoder(L2);
	resetMotorEncoder(L3);
	resetMotorEncoder(L4);
	//Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.

	while(SensorValue[dgtl1]>1000)
	{
		//Proportional algorithm to keep the robot going straight.
		dleft(masterPower);
		dright(slavePower);

		error = (((getMotorEncoder(L2) + getMotorEncoder(L2) + getMotorEncoder(L4) + getMotorEncoder(L4)) / 4) + ((getMotorEncoder(R2) + getMotorEncoder(R2) + getMotorEncoder(R2) + getMotorEncoder(R2)) / 4));
		slavePower += error / kp;

		//Add this iteration's encoder values to totalTicks.

		resetMotorEncoder(R1);
		resetMotorEncoder(R2);
		resetMotorEncoder(R3);
		resetMotorEncoder(R4);
		resetMotorEncoder(L1);
		resetMotorEncoder(L2);
		resetMotorEncoder(L3);
		resetMotorEncoder(L4);

		wait1Msec(30);

		//Add this iteration's encoder values to totalTicks.
	}
	dmotors(0,0);
}
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
void moboDrop(int time){
	dmotors(127,127);
	wait1Msec(500);
	motor[mobol] = -127;
	motor[mobor] = -127;
	wait1Msec(250);
	dmotors(-127,-127);
	motor[mobol] = 127;
	motor[mobor] = 127;
	wait1Msec(250);
	motor[mobol] = 0;
	motor[mobor] = 0;
}
void moboDropTime(int t){
	dmotors(127,127);
	wait1Msec(t);
	motor[mobol] = -127;
	motor[mobor] = -127;
	wait1Msec(250);
	dmotors(-127,-127);
	motor[mobol] = 127;
	motor[mobor] = 127;
	wait1Msec(250);
	motor[mobol] = 0;
	motor[mobor] = 0;
	wait1Msec(t);
	motor[mobol] = 0;
	motor[mobor] = 0;
}

task moboDown(){
	motor[mobol] = -127;
	motor[mobor] = -127;
	wait1Msec(700);
	motor[mobol] = 0;
	motor[mobor] = 0;
}

task moboUp(){
	motor[mobol] = 127;
	motor[mobor] = 127;
	wait1Msec(700);
	motor[mobol] = 0;
	motor[mobor] = 0;
}

task autonomous()
{
	//START
	//GET #1
	startTask(moboDown);
	wait1Msec(400);
	driveTillGoal(120);
	startTask(moboUp);
	wait1Msec(500);

	//DROP #1
	dualControl(200);
	driveFeetDistance(2,120);
	moboDropTime(128);//right start

	//GET #2
	dualControl(180);
	startTask(moboDown);
	driveFeetDistance(2,120);
	startTask(moboUp);

	//DROP #2
	driveFeetDistance(2,120);
	dualControl(-90);
	driveFeetDistance(1,120);
	dualControl(90);
	moboDrop(500);//far opp

	//Line UP
	dualControl(90);
	driveFeetDistance(2,-120);
	dualControl(90);
	driveTillLine(120);

	//GET #3
	driveFeetDistance(1,120);
	startTask(moboUp);

	//DROP #3
	driveTillLine(-120);
	dualControl(-135);
	driveFeetDistance(2,120);
	dualControl(-90);
	moboDrop(100);//center opp

	//GET #4
	dualControl(-90);
	startTask(moboDown);
	driveFeetDistance(1,120);
	dualControl(-90);
	driveFeetDistance(1,120);
	startTask(moboUp);

	//DROP #4
	dualControl(180);
	moboDrop(100);//left opp

	//GET #5
	dualControl(180);
	driveFeetDistance(3,120);
	startTask(moboUp);

	//DROP #5
	driveFeetDistance(1,120);
	dualControl(-90);
	driveFeetDistance(1,120);
	dualControl(90);
	moboDrop(300);//far start

	//LINE UP
	dualControl(-90);
	driveFeetDistance(2,-120);
	dualControl(-90);
	driveTillLine(120);

	//GET #6
	driveFeetDistance(2,120);
	startTask(moboUp);

	//DROP #6
	driveTillLine(-120);
	dualControl(135);
	driveFeetDistance(1,120);
	dualControl(90);
	moboDrop(100);//left start

	//LINE UP
	driveFeetDistance(0.3,120);
	dualControl(90);
	driveFeetDistance(4,-120);
	dualControl(90);
	driveTillLine(120);

	//GET #7
	driveFeetDistance(2,120);
	startTask(moboUp);

	//DROP #7
	driveTillLine(-120);
	dualControl(-135);
	driveFeetDistance(2,120);
	dualControl(-90);
	moboDrop(100);//center start

	//GET #8
	dualControl(-90);
	driveFeetDistance(0.4,120);
	dualControl(-45);
	driveFeetDistance(4,120);
	startTask(moboUp);

	//DROP #8
	dualControl(-80);
	driveFeetDistance(3,120);
	moboDrop(100);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	// User control code here, inside the loop
	SensorFullCount[Gyro]=1000000;
	SensorFullCount[Gyro]=1000000;
	SensorFullCount[Gyro]=1000000;
	SensorFullCount[Gyro]=1000000;
	SensorFullCount[Gyro]=1000000;
	SensorFullCount[Gyro]=1000000;
	while (true)
	{
		if (vexRT[Btn5D]==1){
			dualControl(180);
		}
		displayNextLCDNumber(SensorValue[Gyro],4);
		clearLCDLine(0);
		if (abs(vexRT[Ch3])>10)
		{
			dleft(vexRT[Ch3]);
		}
		else
		{
			dleft(0);
		}
		if (abs(vexRT[Ch2])>10)
		{
			dright(vexRT[Ch2]);
		}
		else
		{
			dright(0);
		}
		if (vexRT[Btn6D]==1)
		{
			mobo(-127);
		}
		else if (vexRT[Btn6U]==1)
		{
			mobo(127);
		}
		else
		{
			mobo(0);
		}
		if (vexRT[Btn8D]==1)
		{
			motor[port1]=127;
		}
		else
		{
			motor[port1]=0;
		}
		// This is the main execution loop for the user control program.
		// Each time through the loop your program should update motor + servo
		// values based on feedback from the joysticks.

		// ........................................................................
		// Insert user code here. This is where you use the joystick values to
		// update your motors, etc.
		// ........................................................................

		// Remove this function call once you have "real" code.
	}
}
