#pragma config(Sensor, in3,    BATERY_2_PORT,  sensorNone)
#pragma config(Motor,  port1,           mobileBoiBaseR, tmotorNone, openLoop)
#pragma config(Motor,  port2,           drFrBrBase,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           coneIntake,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontLeftDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           frontRightDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           backLeftDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           backRightDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          mobileBoiBaseL, tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

//This code is for the VEX cortex platform
#pragma platform(VEX2)
//Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
void pre_auton()
{
bStopTasksBetweenModes = true;
}
//declaration of drive values: 0 is stopped, 1 is driving forward, 2 is driving backwards
int leftDrive = 0, rightDrive = 0, mogoLift = 0, drFrBrBaseVal = 0, drFrBrTop = 0, coneIntakeVal = 0;
//declaration of numerical operands for functions and IMEs
float kP = .2, fRSpeed = 120., fLSpeed = 120., rMod = 0., error = 0.;

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task autonomous()
{

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Tasks                                        */
/*                                                                           */
/*  This task is used to control stacking robot during the user control      */
/*   phase of a VEX Competition.                                             */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

//~~~~~~~auton driving functions~~~~~~~\\
void driveForward (int tdelay){
	motor [frontLeftDrive] = 127;
	motor [frontRightDrive] = 127;
	motor [backLeftDrive] = 127;
	motor [backRightDrive] = 127;
	delay(tdelay);
}
void driveBackwards (int tdelay){
	motor [frontLeftDrive] = -127;
	motor [frontRightDrive] = -127;
	motor [backLeftDrive] = -127;
	motor [backRightDrive] = -127;
	delay(tdelay);
}
void stopDriveTrain (){
	motor [frontLeftDrive] = 0;
	motor [frontRightDrive] = 0;
	motor [backLeftDrive] = 0;
	motor [backRightDrive] = 0;
}
void mobilePush (int tdelay){
	motor [mobileBoiBaseL] = 127;
	motor [mobileBoiBaseR] = 127;
	delay(tdelay);
}
void mobilePull (int tdelay){
	motor [mobileBoiBaseL] = -127;
	motor [mobileBoiBaseR] = -127;
	delay(tdelay);
}
void mobileStop (int tdelay) {
	motor [mobileBoiBaseL] = 0;
	motor [mobileBoiBaseR] = 0;
	delay(tdelay);
}
void driveDosBouysAuton(string motot1, string motot2, int driveType, int tdelay){
	//0 corresponds to stop, 1 corresonds to forward, 2 corresponds to backwards
	switch(driveType){
		case(0):
			motor[motot1] = 0;
			motor[motot2] = 0;
		case(1):
			motor[motot1] = 127;
			motor[motot2] = 127;
		case(2):
			motor[motot1] = -127;
			motor[motot2] = -127;
	}
	delay(tdelay);
}

//~~~~~~~sensor functions~~~~~~~\\
void potentiomReset() {
	//SensorValue[leftBackDrivePot] = 0;
	//SensorValue[rightBackDrivePot] = 0;
}
void imeReset(){
  nMotorEncoder[frontLeftDrive] = 0;
  nMotorEncoder[frontRightDrive] = 0;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task usercontrol()
{

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~LCD_FUNCTIONS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
//^I haven't touched dis
	//sensorResetDT(); <- UPDATE DIS BOI
  string mainBattery, backupBattery; //Set up Variables "mainBattery" "backupBattery"
  bLCDBacklight = true; //Turn on the Backlight in the LCD
	int X1 = 0, Y2 = 0, threshold = 25; //Set Integer Variables
	while (1==1)
	{
		clearLCDLine(0); //Clears the Top Sectio
 		clearLCDLine(1); //Clears the Bottom Section
		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the Value to be Displayed
		displayNextLCDString(mainBattery);
 		int battery2Level = (int)((float)SensorValue[ BATERY_2_PORT ] * 5.48);
		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", battery2Level, 'V');    //Build the Value to be Displayed
		displayNextLCDString(backupBattery);

//~~~~~~~~~~~~~~~~~~Drivetrain PID~~~~~~~~~~~~~~~~~~~~~//

		//front alignment check every 600 ticks, calculate error
		if (nMotorEncoder[frontLeftDrive] || nMotorEncoder[frontRightDrive] >= 600){
			error = nMotorEncoder[frontLeftDrive] - nMotorEncoder[frontRightDrive];
			fRSpeed += error * kP;
			imeReset();
		}

//~~~~~~~~~~~~~~~~~~~~~~~Driver_Control_Controller_1~~~~~~~~~~~~~~~~~~~~~~~~~//
	  //if right joystick up || down
		if(abs(vexRT[Ch2]) > threshold){
			if(vexRT[Ch2] < 0){
				X1 = -1;
			}else if(vexRT[Ch2] > 0){
				X1 = 1;
			}
		}else{
			X1 = 0;
		}
		//if left joystick up || down
		if(abs(vexRT[Ch3]) > threshold){
			Y2 = vexRT[Ch3];
		}else{
			Y2 = 0;
		}//drive the bois
		motor[frontLeftDrive] = Y2;
		motor[frontRightDrive] = X1 * fRSpeed;
		motor[backLeftDrive] = Y2;
		motor[backRightDrive] = X1 * fRSpeed;

		//if right top trigger pressed
		if (vexRT[Btn6U] == 1){
			mogoLift = 1;
			motor [mobileBoiBaseL] = 127;
			motor [mobileBoiBaseR] = 127;
		}
		//if right bottom trigger pressed
		else if (vexRT[Btn6D] == 1){
			mogoLift = 2;
			motor [mobileBoiBaseL] = -127;
			motor [mobileBoiBaseR] = -127;
		}else{
			mogoLift = 0;
			motor [mobileBoiBaseL] = 0;
			motor [mobileBoiBaseR] = 0;
		}

//~~~~~~~~~~~~~~~~~~~~~~driver_2~~~~~~~~~~~~~~~~~~~~~~~//

		//Cone intake control
		if(vexRT [Btn5UXmtr2]==1){
			coneIntakeVal = 1;
			motor[coneIntake] = 127;
		}
		else if(vexRT [Btn5DXmtr2]==1) {
			coneIntakeVal = 2;
	    		motor[coneIntake] = -127;
		}
		else if(coneIntakeVal == 1 || 2){
			coneIntakeVal = 0;
			motor[coneIntake] = 0;
		}

		//Drive fourbar base (motors y'd)
		if(abs(vexRT[Ch2Xmtr2]) > threshold){
			if (vexRT[Ch2Xmtr2] > 0){ drFrBrBaseVal = 1; }else{ drFrBrBaseVal = 2; }
			motor[drFrBrBase] = vexRT[Ch2Xmtr2];
		}
		else{
			drFrBrBaseVal = 0;
			motor[drFrBrBase] = 0;
		}

		//Top bois
		bool ClawUse;
		if(vexRT [Btn6UXmtr2]==1){
			ClawUse = true;
			//motor [ClawOC] = -90;
		}
		else if(vexRT [Btn6DXmtr2]==1) {
			ClawUse = true;
			//motor [ClawOC] = 90;
		}
		else if(ClawUse == true)
			{
			ClawUse = false;
			//motor [ClawOC]=0;
		}
}
}
