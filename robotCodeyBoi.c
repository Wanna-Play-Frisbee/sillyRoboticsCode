#pragma config(Sensor, in3, BATERY_2_PORT, sensorNone) //detection of the second battery status
#pragma config(Motor,  port2,           drFrBrBaseR,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           drFrBrBaseL,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontLeftDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           frontRightDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           backLeftDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           backRightDrive, tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

//This code is for the VEX cortex platform
#pragma platform(VEX2)
//Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
void pre_auton()
{
bStopTasksBetweenModes = true;
}
//declaration of drive values: 0 is stopped, 1 is driving forward, 2 is driving backwards
int leftDrive = 0, rightDrive = 0, mogoLift = 0, drFrBrBase = 0, drFrBrTop = 0;
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task autonomous()
{
/*if(SensorValue[] <= 400) //MGLb 5 point
  {
 	sensorResetDT();
	}
		stopDriveTrain();


if(SensorValue[AutoSelect] > 400 && SensorValue[AutoSelect] <1400) //MGRr 10 points
    {

    }
if(SensorValue[AutoSelect] >= 1400) //SGC
    {

    }*/
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Tasks                                        */
/*                                                                           */
/*  This task is used to control stacking robot during the user control      */
/*   phase of a VEX Competition.                                             */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
bool VertLiftUse;

void driveForward (int tdelay){
			motor [frontLeftDrive] = 127;
			motor [frontRightDrive] = 127;
			motor [backLeftDrive] = 127;
			motor [backRightDrive] = 127;
			delay(tdelay);
}
void driveBackwards (int tdelay){
			motor [frontLeftDrive] = -127;
			motor [frontRightDrive] = -127;
			motor [backLeftDrive] = -127;
			motor [backRightDrive] = -127;
			delay(tdelay);
}
void stopDriveTrain (){
			motor [frontLeftDrive] = 0;
			motor [frontRightDrive] = 0;
			motor [backLeftDrive] = 0;
			motor [backRightDrive] = 0;
}
void mobilePush (int tdelay){
			//motor [mobileLiftLeft] = 127;
			//motor [mobileLiftRight] = 127;
			delay(tdelay);
}
void mobilePull (int tdelay){
			//motor [mobileLiftLeft] = -127;
			//motor [mobileLiftRight] = -127;
			delay(tdelay);
}
void mobileStop (int tdelay) {
			//motor [mobileLiftLeft] = 0;
			//motor [mobileLiftRight] = 0;
			delay(tdelay);
}
void sensorResetDT() {
	//SensorValue[leftBackDrivePot] = 0;
	//SensorValue[rightBackDrivePot] = 0;
}

void imeClearing (int *motot){
  for (int i = 0; i < sizeof(motot); i++){
  	nMotorEncoder[motot[i]] = 0;
  }
}

void driveDosBouysAuton(string motot1, string motot2, int driveType, int tdelay){
	//0 corresponds to stop, 1 corresonds to forward, 2 corresponds to backwards
	switch(driveType){
		case(0):
			motor[motot1] = 0;
			motor[motot2] = 0;
		case(1):
			motor[motot1] = 127;
			motor[motot2] = 127;
		case(2):
			motor[motot1] = -127;
			motor[motot2] = -127;
	}
	delay(tdelay);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task usercontrol()
{

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~LCD_FUNCTIONS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
	//sensorResetDT(); <- UPDATE DIS BOI
  string mainBattery, backupBattery; //Set up Variables "mainBattery" "backupBattery"
  bLCDBacklight = true; //Turn on the Backlight in the LCD
	int X1 = 0, X2 = 0, Y1 = 0, Y2 = 0, threshold = 5; //Set Integer Variables
	while (1==1)
	{
		clearLCDLine(0); //Clears the Top Sectio
 		clearLCDLine(1); //Clears the Bottom Section
		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the Value to be Displayed
		displayNextLCDString(mainBattery);
 		int battery2Level = (int)((float)SensorValue[ BATERY_2_PORT ] * 5.48);
		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", battery2Level, 'V');    //Build the Value to be Displayed
		displayNextLCDString(backupBattery);
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~end_of_LCD_FUNCTIONS~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\


//~~~~~~~~~~~~~~~~~~~~~~~Driver_Control_Controller_1~~~~~~~~~~~~~~~~~~~~~~~~~//
		if(abs(vexRT[Ch1]) > threshold)
			X1 = vexRT[Ch1];
		else
			X1 = 0;
	  if(abs(vexRT[Ch2]) > threshold)
			Y1 = vexRT[Ch2];
		else
			Y1 = 0;

		if(abs(vexRT[Ch3]) > threshold)
			Y2 = vexRT[Ch3];
		else
			Y2 = 0;

		if(abs(vexRT[Ch4]) > threshold)
			X2 = vexRT[Ch4];
		else
			X2 = 0;
   	motor[frontLeftDrive] = Y2;
		motor[frontRightDrive] = Y1;
		motor[backLeftDrive] = Y2;
		motor[backRightDrive] = Y1;
//~~~~~~~~~~~~~end_of_Driver_Control_Controller_1~~~~~~~~~~~~~~\\

//~~~~~~~~~~~~~~~~~~~~~~~~~driver_2~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

		//Lift_Control_Controller 2
		//Up&Down
		if(vexRT [Btn5UXmtr2]==1){
			drFrBrBase = 1;
			motor[drFrBrBaseR] = 127;
			motor[drFrBrBaseL] = 127;
		}
		else if(vexRT [Btn5DXmtr2]==1) {
			drFrBrBase = 2;
	    motor[drFrBrBaseR] = -127;
			motor[drFrBrBaseL] = -127;
		}
		else if(VertLiftUse == 1 || 2)
			{
			drFrBrBase = 0;
	}

		//Rotate --- Controller 2
		bool RotatingClawUse;
		if(abs(vexRT[Ch2Xmtr2]) > threshold)
		{
			RotatingClawUse = true;
			//motor [LiftClawRotate]=-vexRT[Ch2Xmtr2];
		}
		else if(RotatingClawUse == true)
		{
			RotatingClawUse = false;
 			//motor [LiftClawRotate]= 0;
		}

		//Claw Control --- Controller 2
		//Open&Close
		bool ClawUse;
		if(vexRT [Btn6UXmtr2]==1){
			ClawUse = true;
			//motor [ClawOC] = -90;
		}
		else if(vexRT [Btn6DXmtr2]==1) {
			ClawUse = true;
			//motor [ClawOC] = 90;
		}
		else if(ClawUse == true)
			{
			ClawUse = false;
			//motor [ClawOC]=0;
		}
}
