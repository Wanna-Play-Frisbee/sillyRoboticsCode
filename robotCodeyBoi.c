#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  numberOne,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  numberTwo,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  mobileTouchTouch, sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           mobileBoiBaseR, tmotorNone, openLoop)
#pragma config(Motor,  port2,           drFrBrBase,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           coneIntake,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           frontLeftDrive, tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           frontRightDrive, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port6,           backLeftDrive, tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port7,           backRightDrive, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port8,           rightTop,      tmotorNone, openLoop)
#pragma config(Motor,  port9,           leftTop,       tmotorNone, openLoop)
#pragma config(Motor,  port10,          mobileBoiBaseL, tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

//This code is for the VEX cortex platform
#pragma platform(VEX2)
//Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
void pre_auton()
{
bStopTasksBetweenModes = true;
}
//declaration of drive values: 0 is stopped, 1 is driving forward, 2 is driving backwards
int leftDrive = 0, rightDrive = 0, mogoLift = 0, drFrBrBaseVal = 0, drFrBrTop = 0, coneIntakeVal = 0;
//declaration of numerical operands for functions and IMEs
float kP = .2, fRSpeed = 120., fLSpeed = 120., rMod = 0., error = 0.;

//~~~~~~~auton driving functions~~~~~~~\\
		//declare necessary variables
		int rightAutonSpeed = 125;	int leftAutonSpeed = 125; int	autonomousIMEtotalFR = 0, autonomousIMEtotalFL = 0;

void driveForward (int rSpeed, int tdelay){
	motor [frontLeftDrive] = 127;
	motor [frontRightDrive] = rSpeed;
	motor [backLeftDrive] = 127;
	motor [backRightDrive] = rSpeed;
	delay(tdelay); leftDrive = 1; rightDrive = 1;
}
void driveTrainLeft(int mPower, int tdelay){
	motor[frontLeftDrive] = mPower;
	motor[backLeftDrive] = mPower;
	delay(tdelay);
}
void driveBackwards (int rSpeed, int tdelay){
	motor [frontLeftDrive] = -127;
	motor [frontRightDrive] = -1 * rSpeed;
	motor [backLeftDrive] = -127;
	motor [backRightDrive] = -1 * rSpeed;
	delay(tdelay); leftDrive = 2; rightDrive = 2;
}
void stopDriveTrain (){
	motor [frontLeftDrive] = 0;
	motor [frontRightDrive] = 0;
	motor [backLeftDrive] = 0;
	motor [backRightDrive] = 0;
	leftDrive = 0; rightDrive = 0;
}
void mobileDrive (int mPower, int tdelay){
	motor [mobileBoiBaseL] = mPower;
	motor [mobileBoiBaseR] = mPower;
	delay(tdelay);
}
void stopDTyMobi(){
	motor[frontLeftDrive] = 0;
	motor[backLeftDrive] = 0;
	motor[frontRightDrive] = 0;
	motor[backRightDrive] = 0;
	motor[mobileBoiBaseL] = 0;
	motor[mobileBoiBaseR] = 0;
	leftDrive = 0; rightDrive = 0; mogoLift = 0;
}

void driveDosBouysAuton(string motot1, string motot2, int driveType, int tdelay, int speedyBoi){
	//0 corresponds to stop, 1 corresonds to forward, 2 corresponds to backwards
	switch(driveType){
		case(0):
			motor[motot1] = speedyBoi;
			motor[motot2] = speedyBoi;
		case(1):
			motor[motot1] = speedyBoi;
			motor[motot2] = speedyBoi;
		case(2):
			motor[motot1] = speedyBoi;
			motor[motot2] = speedyBoi;
	}
	delay(tdelay);
}

//~~~~~~~sensor functions~~~~~~~\\
void potentiomReset() {
	//SensorValue[leftBackDrivePot] = 0;
	//SensorValue[rightBackDrivePot] = 0;
}
void imeReset(){
  nMotorEncoder[frontLeftDrive] = 0;
  nMotorEncoder[frontRightDrive] = 0;
}
void autonAddition(){
	autonomousIMEtotalFL += nMotorEncoder[frontLeftDrive];
	autonomousIMEtotalFR += nMotorEncoder[frontRightDrive];
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task autonomous()
{
	//open mobile lift and   d r i v e   a tiny bit
	mobileDrive(127, 1150);
	driveForward(rightAutonSpeed, 200);
	mobileDrive(0, 100);
	
	//   d a n i e l    s t o p    i t
	stopDriveTrain(); autonAddition();
	
	//spinnnnnnn
	while (nMotorEncoder(frontLeftDrive) < 300){
		driveTrainLeft(127, 0);
	} autonAddition(); imeReset();
	
	while (SensorValue[mobileTouchTouch] != 1) {
		if (abs(nMotorEncoder[frontLeftDrive]) || abs(nMotorEncoder[frontRightDrive]) >= 600){
			error = nMotorEncoder[frontLeftDrive] - nMotorEncoder[frontRightDrive]; autonAddition();
			rightAutonSpeed += error * kP; imeReset();
			driveForward(rightAutonSpeed, 200);
		}
	}
	//when touchy, do:
	stopDTyMobi();
	imeReset();
	
	//pull in mobile boi
	mobileDrive(-127, 1250);
	
	while (SensorValue[frontLeftDrive] && SensorValue[frontRightDrive] < 600){
		driveBackwards(rightAutonSpeed, 0);	
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Tasks                                        */
/*                                                                           */
/*  This task is used to control stacking robot during the user control      */
/*   phase of a VEX Competition.                                             */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

//no u, finna dab

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task usercontrol()
{

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~LCD_FUNCTIONS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
//I haven't touched dis
	imeReset();
  string mainBattery, backupBattery; //Set up Variables "mainBattery" "backupBattery"
  bLCDBacklight = true; //Turn on the Backlight in the LCD
	int X1 = 0, Y2 = 0, threshold = 25; //Set Integer Variables
	while (1==1)
	{
		clearLCDLine(0); //Clears the Top Sectio
 		clearLCDLine(1); //Clears the Bottom Section
		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "REEEEEEE");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the Value to be Displayed
		displayNextLCDString(mainBattery);
 		//int battery2Level = (int)((float)SensorValue[ BATERY_2_PORT ] * 5.48);
		//Display the Backup battery voltage
		displayLCDString(1, 0, "REEEEEEE");
		//printf(backupBattery, "%1.2f%c", battery2Level, 'V');    //Build the Value to be Displayed
//~~~~~~~~~~~~~~~~~~Drivetrain PID~~~~~~~~~~~~~~~~~~~~~//

		//front alignment check every 600 ticks, calculate error
		if (abs(nMotorEncoder[frontLeftDrive]) || abs(nMotorEncoder[frontRightDrive]) >= 600){
			error = nMotorEncoder[frontLeftDrive] - nMotorEncoder[frontRightDrive];
			fRSpeed += error * kP;
			imeReset();
		}

//~~~~~~~~~~~~~~~~~~~~~~~Driver_Control_Controller_1~~~~~~~~~~~~~~~~~~~~~~~~~//
	  //if right joystick up || down
		if(abs(vexRT[Ch2]) > threshold){
			if(vexRT[Ch2] < 0){
				X1 = -1;
			}else if(vexRT[Ch2] > 0){
				X1 = 1;
			}
		}else{
			X1 = 0;
		}
		//if left joystick up || down
		if(abs(vexRT[Ch3]) > threshold){
			Y2 = vexRT[Ch3];
		}else{
			Y2 = 0;
		}//drive the bois
		motor[frontLeftDrive] = Y2;
		motor[frontRightDrive] = X1 * fRSpeed;
		motor[backLeftDrive] = Y2;
		motor[backRightDrive] = X1 * fRSpeed;

		//if right top trigger pressed
		if (vexRT[Btn6U] == 1){
			mogoLift = 1;
			motor [mobileBoiBaseL] = 127;
			motor [mobileBoiBaseR] = 127;
		}
		//if right bottom trigger pressed
		else if (vexRT[Btn6D] == 1){
			mogoLift = 2;
			motor [mobileBoiBaseL] = -127;
			motor [mobileBoiBaseR] = -127;
		}else{
			mogoLift = 0;
			motor [mobileBoiBaseL] = 0;
			motor [mobileBoiBaseR] = 0;
		}

//~~~~~~~~~~~~~~~~~~~~~~driver_2~~~~~~~~~~~~~~~~~~~~~~~//

		//Cone intake control
		if(vexRT [Btn5UXmtr2]==1){
			coneIntakeVal = 1;
			motor[coneIntake] = 127;
		}
		else if(vexRT [Btn5DXmtr2]==1) {
			coneIntakeVal = 2;
	    		motor[coneIntake] = -127;
		}
		else if(coneIntakeVal == 1 || 2){
			coneIntakeVal = 0;
			motor[coneIntake] = 0;
		}

		//Drive fourbar base (motors y'd)
		if(abs(vexRT[Ch2Xmtr2]) > threshold){
			if (vexRT[Ch2Xmtr2] > 0){ drFrBrBaseVal = 1; }else{ drFrBrBaseVal = 2; }
			motor[drFrBrBase] = vexRT[Ch2Xmtr2];
		}
		else{
			drFrBrBaseVal = 0;
			motor[drFrBrBase] = 0;
		}

		//Top bois
		if(abs(vexRT[Ch3Xmtr2]) > threshold){
			if (vexRT[Ch3Xmtr2] > 0){ drFrBrTop = 1; }else{ drFrBrTop = 2; }
			motor[leftTop] = vexRT[Ch3Xmtr2]; motor[rightTop] = vexRT[Ch3Xmtr2];
		}
		else{
			drFrBrTop = 0;
			motor[leftTop] = 0; motor[rightTop] = 0;
		}
}
}
